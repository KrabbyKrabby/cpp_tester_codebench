{
    "time_to_develop_prompt": "> 40",
    "programming_language": "C++",
    "task_type": "Enhancement",
    "difficulty": "3",
    "estimated_skill_requirements": "Library Feature,Data Structure and Algorithms,Software Engineering Best Practices",
    "user_prompt": "Base Code:\n```cpp\n#include <functional>\n#include <queue>\n#include <stdexcept>\n#include <vector>\n#include <iostream>\n\n\n// A simple Task struct. Right now, it only holds a function.\n// In your enhancements, you may need to expand this (e.g., ID, status, schedule time, etc.).\nstruct Task {\n    std::function<void()> func;\n};\n\n// A simple FIFO TaskScheduler that runs tasks one-by-one.\nclass TaskScheduler {\npublic:\n    TaskScheduler() = default;\n    ~TaskScheduler() = default;\n\n    // Add a task to the queue (returns the index in the queue, but isn't used for anything yet).\n    size_t addTask(const std::function<void()>& func) {\n        Task task{func};\n        tasks.push(task);\n        return tasks.size() - 1; // simplistic; not truly an ID\n    }\n\n    // Runs the next task in the queue if one exists, then removes it from the queue.\n    void runNext() {\n        if (tasks.empty()) {\n            return;\n        }\n        Task t = tasks.front();\n        tasks.pop();\n        // Execute\n        t.func();\n    }\n\n\nprivate:\n    std::queue<Task> tasks;\n};\n\n\n```\n\n\n\nPrompt:\nCurrently the `TaskScheduler` class allows you to add tasks (simple std::function<void()> objects) to a queue and run them in a single-threaded, FIFO manner. Currently, the scheduler is very limited: it just enqueues tasks and executes them one at a time via `runNext()`.\n\nEnhance this `TaskScheduler` with the following requirements:\n\nImplement a function `void runAllConcurrently()`; that executes all currently queued tasks using multiple threads.\nOnce started, it should not block the caller; i.e., runAllConcurrently() should spawn threads (where the number of threads is up to you, but do not block the main thread until all tasks finish).\nProvide a mechanism to gracefully wait for all tasks to complete if needed, with a new thread-safe function `void waitAll()`;. \n\nProvide a function `size_t` `scheduleTask(std::chrono::system_clock::time_point time, std::function<void()> task);` that queues a task to be executed not before the specified time.\nIf `runNext()` or `runAllConcurrently()` is invoked, only tasks whose scheduled time has passed are eligible to run. Others must wait until their time has arrived.\nThe return value should be a task ID (a unique identifier for the scheduled task).\n\n\nIntroduce a type `enum` class `TaskStatus { PENDING, RUNNING, COMPLETED, CANCELED };`.\nAdd a function `TaskStatus getTaskStatus(size_t taskId) const;` that returns the status of a task.\n`PENDING` means queued but not started (including future-scheduled tasks before execution time).\n`RUNNING` means currently executing.\n`COMPLETED` means the task finished successfully.\n`CANCELED` means the task was explicitly canceled before it could complete.\nAdd a function `bool cancelTask(size_t taskId);` that attempts to cancel a `PENDING` task. If a task is already RUNNING or COMPLETED, cancellation fails (returns false).\n\n\nAll of the above must be done in a thread-safe manner (e.g., using mutexes or other synchronization) and you must ensure that your design works with both single-threaded (current runNext()) and multi-threaded modes (runAllConcurrently()). Lastly, your modifications should not break the existing tests and you must return the entire code along with your modifications. Do not include the `main` function."
}