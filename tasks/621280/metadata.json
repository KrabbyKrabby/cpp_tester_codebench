{
    "time_to_develop_prompt": "> 40",
    "programming_language": "C++",
    "task_type": "Refactor",
    "difficulty": "3",
    "estimated_skill_requirements": "Software Engineering Best Practices,Data Structure and Algorithms,Library Feature",
    "user_prompt": "Base Code:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\nclass Employee {\npublic:\n    std::string name;\n    int age;\n    std::string department;\n    double salary;\n\n    Employee(const std::string& name, int age, const std::string& department, double salary)\n        : name(name), age(age), department(department), salary(salary) {}\n};\n\nclass Company {\npublic:\n    std::vector<Employee> employees;\n\n    // Adds a new employee to the company.\n    void addEmployee(const std::string& name, int age, const std::string& department, double salary) {\n        employees.push_back(Employee(name, age, department, salary));\n    }\n\n    // Removes an employee by name. Returns true if the employee was found and removed.\n    bool removeEmployee(const std::string& name) {\n        for (auto it = employees.begin(); it != employees.end(); ++it) {\n            if (it->name == name) {\n                employees.erase(it);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // Prints basic employee information to the console.\n    void printEmployees() const {\n        for (const auto& employee : employees) {\n            std::cout << \"Name: \" << employee.name\n                      << \", Age: \" << employee.age\n                      << \", Department: \" << employee.department\n                      << \", Salary: \" << employee.salary << \"\\n\";\n        }\n    }\n\n    // Gives a raise by percentage to all employees in a given department.\n    void giveRaiseByDepartment(const std::string& department, double percentage) const {\n        for (auto& employee : employees) {\n            if (employee.department == department) {\n                employee.salary += employee.salary * percentage / 100.0;\n            }\n        }\n    }\n\n    // Computes and returns the average salary among all employees.\n    double getAverageSalary() {\n        if (employees.empty()) {\n            return 0.0;\n        }\n        double total = 0.0;\n        for (const auto& employee : employees) {\n            total += employee.salary;\n        }\n        return total / employees.size();\n    }\n\n    // Returns a list of employees in a specific department.\n    std::vector<Employee> getEmployeesInDepartment(const std::string& department) {\n        std::vector<Employee> result;\n        for (const auto& employee : employees) {\n            if (employee.department == department) {\n                result.push_back(employee);\n            }\n        }\n        return result;\n    }\n};\n\n```\n\nPrompt:\nHere's a C++ program that manages a list of Employee objects within a `Company` class. Currently, `Company` handles everything\u2014adding/removing employees, giving raises, computing average salary, printing, etc. This design is not ideal because:\n- It violates the Single Responsibility Principle (one class doing too many things).\n- It lacks thread safety, making it risky to use in concurrent environments.\n- Computing the average salary can be inefficient for very large datasets, as it recalculates from scratch every time.\n- It\u2019s not easily extensible for new employee-related features.\n\nYour task is to refactor this code while preserving the existing functionality and public method signatures. You will do the following.\n- Introduce a new `EmployeeManager` class (or similarly named) to handle all employee-related logic. The `Company` class should delegate to it.\n- Implement thread safety using proper locking or concurrency techniques.\n- Optimize average salary computation (via caching, incremental updates, or other efficient means).\n- Preserve the existing Company public methods\u2019 signatures so any old code using them remains valid.\n- Keep the overall design maintainable and extensible by adopting modern C++ (C++17) best practices (smart pointers, structured bindings, range-based loops, RAII, etc.).\n- The existing test suite (not shown here) must pass without modifications.\n- Return the entire code along with your modifications.\n- Do not include the main function.\n\nAfter refactoring, provide:\nA short explanation of how you approached concurrency, caching, and method delegation."
}