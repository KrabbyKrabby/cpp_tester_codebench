{
    "time_to_develop_prompt": "30 -40",
    "programming_language": "C++",
    "task_type": "Refactor",
    "difficulty": "5",
    "estimated_skill_requirements": "Knowledge of a Specialized Software Area",
    "user_prompt": "Base Code:\n```cpp\n#include <iostream>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\nusing namespace std;\n\n// Function to find modular exponentiation\nlong long modExp(long long base, long long exp, long long mod) {\n    long long result = 1;\n    base = base % mod;\n    while (exp > 0) {\n        if (exp % 2 == 1) {\n            result = (result * base) % mod;\n        }\n        exp = exp >> 1;\n        base = (base * base) % mod;\n    }\n    return result;\n}\n\nint main() {\n    srand(time(0));\n\n    // Step 1: Generate a large prime number p (example prime)\n    int p = 23; // Example prime (in real applications, use much larger primes)\n\n    // Step 2: Choose a primitive root g modulo p\n    int g = 5; // Primitive root of 23\n\n    // Step 3: Private key selection (a random integer < p)\n    int privateKey = rand() % (p - 1) + 1; // Ensure privateKey > 0\n\n    // Step 4: Compute public key (g^privateKey mod p)\n    int publicKey = modExp(g, privateKey, p);\n\n    cout << \"Public Parameters: p = \" << p << \", g = \" << g << endl;\n    cout << \"Private Key: \" << privateKey << endl;\n    cout << \"Public Key: \" << publicKey << endl;\n\n    // Step 5: Encryption\n    cout << \"\\nEnter a message (as an integer less than p): \";\n    int message;\n    cin >> message;\n\n    // Generate random ephemeral key (k)\n    int k = rand() % (p - 1) + 1; // Ensure k > 0\n\n    // Compute ephemeral public key (g^k mod p)\n    int ephemeralKey = modExp(g, k, p);\n\n    // Compute the shared secret (publicKey^k mod p)\n    int sharedSecret = modExp(publicKey, k, p);\n\n    // Encrypt the message\n    int encryptedMessage = (message * sharedSecret) % p;\n\n    cout << \"Ephemeral Key: \" << ephemeralKey << endl;\n    cout << \"Encrypted Message: \" << encryptedMessage << endl;\n\n    // Step 6: Decryption\n    // Compute shared secret for decryption (ephemeralKey^privateKey mod p)\n    int decryptionSecret = modExp(ephemeralKey, privateKey, p);\n\n    // Modular multiplicative inverse of decryptionSecret\n    int decryptionSecretInverse = 0;\n    for (int i = 1; i < p; i++) {\n        if ((decryptionSecret * i) % p == 1) {\n            decryptionSecretInverse = i;\n            break;\n        }\n    }\n\n    // Decrypt the message\n    int decryptedMessage = (encryptedMessage * decryptionSecretInverse) % p;\n\n    cout << \"Decrypted Message: \" << decryptedMessage << endl;\n\n    return 0;\n}\n```\n\nPrompt:\nI have this code that implements El-Gamal encryption and decryption algorithm. I want you to modify this code version to encrypt and decrypt text messages instead of numerical messages. Please, create a new class called `ElGamal` which has two functions; `Encrypt` and `Decrypt` and move all the logic from the main function to these functions and define the `p` and `g` as private variables in the class not in the main. The class should only include a default constructor to set the needed values. Don't provide the `main` function in your code. The `Encrypt` function should take only the plaintext as a parameter and return the encrypted message. The `Decrypt` function should take only the encrypted message as a parameter and return the decrypted message."
}