{
    "time_to_develop_prompt": "> 40",
    "programming_language": "C++",
    "task_type": "Bug Fix",
    "difficulty": "3",
    "estimated_skill_requirements": "Language-Specific Features,Data Structure and Algorithms",
    "user_prompt": "Base Code:\n```cpp\n#include <iostream>\n#include <vector>\n\nstd::pair<int, std::vector<int>> findMissingBandwidthPackages(std::vector<int>& bandwidthPackages, int maxBandwidth) {\n    int currentCoverage = 0; // Tracks the current maximum bandwidth we can cover\n    int missingPackageCount = 0; // Counts the number of missing packages added\n    std::vector<int> addedPackages; // Stores the missing packages added\n    int index = 0; // Tracks the index in the bandwidthPackages array\n    \n    while (currentCoverage != maxBandwidth && index < bandwidthPackages.size()) {\n        if (bandwidthPackages[index] == currentCoverage + 1) {\n            currentCoverage += 1;\n            index++;\n            continue;\n        } else {\n            addedPackages.push_back(currentCoverage + 1);\n            missingPackageCount += 1;\n            currentCoverage += 1;\n        }\n    }\n    if (currentCoverage != maxBandwidth) {\n        for (int i = currentCoverage + 1; i <= maxBandwidth; i++) {\n            addedPackages.push_back(i);\n            missingPackageCount += 1;\n        }\n    }    \n    \n    return {missingPackageCount, addedPackages};\n}\n```\n\nPrompt:\nI have a list of available bandwidth packages, for example, `[10, 30, 20]`, and a maximum bandwidth requirement (`maxBandwidth`). The goal is to add new packages to the `bandwidthPackages` list so that any requested bandwidth in the range `[1, maxBandwidth]` can be achieved by combining one or more packages, including both the initial packages and any new ones added. The function should return a pair consisting of the minimum number of additional bandwidth packages required to cover the entire range `[1, maxBandwidth]` and a list of the new bandwidth packages that need to be added.\n\nExample:\nInput:  \nInitial `bandwidthPackages`: `{1, 3}`  \nMaximum `maxBandwidth`: `6`  \nOutput:  \n`{1, {2}}`\nExample explanation:  \nUsing the initial `bandwidthPackages` `{1, 3}`, the possible sums are: 1, 3, 4 (from combinations [1], [3], [1, 3]). The range [1, 6] is not fully covered since 2, 5, and 6 are missing. Adding 2 to `bandwidthPackages` results in new combinations: [1], [2], [3], [1, 3], [2, 3], [1, 2], [1, 2, 3]. This gives possible sums: 1, 2, 3, 4, 5, 6, which fully covers the range [1, 6]. We need only `1` additional package (2), so the output is `{1, {2}}`.\n\nThe function `findMissingBandwidthPackages` has a bug where it incorrectly adds all missing packages from 1 to `maxBandwidth`. Also, the output sometimes includes numbers that are already present in the input list. I need the function to add only the minimum number of packages required to achieve full coverage. \n\nOther requirements:\n- The input vector `bandwidthPackages` may contain repeated bandwidth values. Each bandwidth available can be used only once, but if multiple instances of the same bandwidth are available, each instance can be used separately.\n- The output should be sorted. If there are multiple possible outputs with the same length, prefer adding the number that is immediately missing during the coverage check.\n- The `maxBandwidth` may be large but within the C++ integer limits. Handle large `maxBandwidth` cases.\n\nGive the complete implementation of the function `findMissingBandwidthPackages` along with the necessary imports, don't include `int main()` function."
}