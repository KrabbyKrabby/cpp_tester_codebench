{
    "time_to_develop_prompt": "> 40",
    "programming_language": "C++",
    "task_type": "Completion",
    "difficulty": "3",
    "estimated_skill_requirements": "Software Engineering Best Practices,Language-Specific Features,Data Structure and Algorithms,Library Feature",
    "user_prompt": "Base Code:\n\n```C++\n#include <iostream>\n#include <vector>\n\ntemplate <typename T>\nclass Stack {\nprivate:\n    std::vector<T> data; // Internal storage for stack elements\n    size_t capacity;     // Maximum capacity of the stack\n\npublic:\n    // Constructor with specified capacity\n    Stack(size_t maxCapacity) : capacity(maxCapacity) {}\n\n    // Push an element onto the stack\n    void push(const T& element) {\n        if (data.size() >= capacity) {\n            std::cerr << \"Stack overflow: Cannot push element, stack is full.\\n\";\n            return;\n        }\n        // TODO: Add the element to the stack\n    }\n\n    // Pop the top element from the stack\n    void pop() {\n        if (data.empty()) {\n            std::cerr << \"Stack underflow: Cannot pop element, stack is empty.\\n\";\n            return;\n        }\n        // TODO: Remove the top element from the stack\n    }\n\n    // Peek at the top element without removing it\n    T top() const {\n        if (data.empty()) {\n            throw std::runtime_error(\"Stack is empty: No top element.\");\n        }\n        // TODO: Return the top element\n    }\n\n    // Check if the stack is empty\n    bool isEmpty() const {\n        // TODO: Return whether the stack is empty\n    }\n\n    // Check if the stack is full\n    bool isFull() const {\n        return data.size() >= capacity;\n    }\n};\n```\n\n\nPrompt: \nComplete the given `Stack` class to support concurrent access using POSIX threads while ensuring data integrity. Implement dynamic capacity adjustments and conduct rigorous testing while handling pthread mutability within static methods.\n\nRequirements:\n1. Thread Safety:\n   - Use POSIX threads (pthread) to handle concurrent `push` and `pop` operations safely.\n   - Implement appropriate synchronization mechanisms (e.g., mutex, condition variables) to prevent race conditions.\n   - Use the `mutable` keyword to allow constant methods to modify synchronization primitives safely.\n\n2. Dynamic Capacity Adjustment:  \n   - Allow the stack's capacity to increase or decrease dynamically during operation while maintaining thread safety.\n   - Ensure data integrity when resizing.\n   - Important: The `resize` function must not attempt to lock the mutex, as it will be called from within methods that already hold the mutex lock.\n\n3. Proper Implementation of Stack Operations:  \n   - `push(const T& element)`: Insert the element while ensuring thread safety and performing dynamic resizing as needed.\n   - `pop()`: Remove the top element. If the stack is empty, print an error message about underflow.\n   - `top()`: Return the top element. If the stack is empty, throw a runtime error.\n   - `isEmpty()` and `isFull()`: Check the state of the stack with thread-safe access.\n\nKeep the existing error handling in the code while ensuring proper vector initialization, avoiding infinite loops or deadlocks caused by incorrect resizing logic. Modify the constructor logic if necessary without modifying the functionality. Ensure the stack can handle thousands of concurrent operations under high load. Break the implementation into smaller, clearly labeled sections (for example, \"Core Functionality\", \"Resizing Logic\", \"Synchronization\") rather than one large block of code.\n\nGive the complete implementation along with necessary imports. "
}