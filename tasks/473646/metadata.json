{
    "time_to_develop_prompt": "> 40",
    "programming_language": "C++",
    "task_type": "Enhancement",
    "difficulty": "4",
    "estimated_skill_requirements": "Knowledge of a Specialized Software Area",
    "user_prompt": "Base Code:\n```cpp\n#include <iostream>\n#include <map>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <iomanip>\n#include <arpa/inet.h>\n#include <sstream>\n\nstruct EthernetHeader\n{\n    unsigned char destMac[6];\n    unsigned char srcMac[6];\n    unsigned short etherType;\n};\n\nstruct IPv4Header\n{\n    unsigned char versionIHL;\n    unsigned char typeOfService;\n    unsigned short totalLength;\n    unsigned short identification;\n    unsigned short flagsFragmentOffset;\n    unsigned char timeToLive;\n    unsigned char protocol;\n    unsigned short headerChecksum;\n    unsigned int srcIp;\n    unsigned int destIp;\n};\n\nstruct TCPHeader\n{\n    unsigned short srcPort;\n    unsigned short destPort;\n    unsigned int sequenceNumber;\n    unsigned int acknowledgmentNumber;\n    unsigned char dataOffsetReserved;\n    unsigned char flags;\n    unsigned short windowSize;\n    unsigned short checksum;\n    unsigned short urgentPointer;\n};\n\nstd::string macToString(const unsigned char *mac)\n{\n    std::ostringstream oss;\n    for (int i = 0; i < 6; ++i)\n    {\n        if (i != 0)\n            oss << \":\";\n        oss << std::hex << std::setw(2) << std::setfill('0') << (int)mac[i];\n    }\n    return oss.str();\n}\n\nstd::string ipToString(unsigned int ip)\n{\n    return std::to_string((ip >> 24) & 0xFF) + \".\" +\n           std::to_string((ip >> 16) & 0xFF) + \".\" +\n           std::to_string((ip >> 8) & 0xFF) + \".\" +\n           std::to_string(ip & 0xFF);\n}\n\nstd::map<std::string, std::string> parseEthernetPacket(const std::vector<unsigned char> &packet)\n{\n    std::map<std::string, std::string> parsedFields;\n\n    if (packet.size() < sizeof(EthernetHeader))\n    {\n        parsedFields[\"Error\"] = \"Packet is too short to contain an Ethernet header.\";\n        return parsedFields;\n    }\n\n    const EthernetHeader *ethHeader = reinterpret_cast<const EthernetHeader *>(packet.data());\n    parsedFields[\"Destination MAC\"] = macToString(ethHeader->destMac);\n    parsedFields[\"Source MAC\"] = macToString(ethHeader->srcMac);\n    parsedFields[\"EtherType\"] = \"0x\" + std::to_string(ntohs(ethHeader->etherType));\n\n    if (ntohs(ethHeader->etherType) != 0x0800)\n    {\n        parsedFields[\"Error\"] = \"Unsupported EtherType. Only IPv4 is supported.\";\n        return parsedFields;\n    }\n\n    if (packet.size() < sizeof(EthernetHeader) + sizeof(IPv4Header))\n    {\n        parsedFields[\"Error\"] = \"Packet is too short to contain an IPv4 header.\";\n        return parsedFields;\n    }\n\n    const IPv4Header *ipHeader = reinterpret_cast<const IPv4Header *>(packet.data() + sizeof(EthernetHeader));\n    parsedFields[\"Source IP\"] = ipToString(ntohl(ipHeader->srcIp));\n    parsedFields[\"Destination IP\"] = ipToString(ntohl(ipHeader->destIp));\n    parsedFields[\"Protocol\"] = std::to_string(ipHeader->protocol);\n\n    if (ipHeader->protocol != 6)\n    {\n        parsedFields[\"Error\"] = \"Unsupported Protocol. Only TCP is supported.\";\n        return parsedFields;\n    }\n\n    if (packet.size() < sizeof(EthernetHeader) + sizeof(IPv4Header) + sizeof(TCPHeader))\n    {\n        parsedFields[\"Error\"] = \"Packet is too short to contain a TCP header.\";\n        return parsedFields;\n    }\n\n    const TCPHeader *tcpHeader = reinterpret_cast<const TCPHeader *>(\n        packet.data() + sizeof(EthernetHeader) + sizeof(IPv4Header));\n    parsedFields[\"Source Port\"] = std::to_string(ntohs(tcpHeader->srcPort));\n    parsedFields[\"Destination Port\"] = std::to_string(ntohs(tcpHeader->destPort));\n\n    // Extract payload and CRC if present\n    size_t headerSize = sizeof(EthernetHeader) + sizeof(IPv4Header) + sizeof(TCPHeader);\n    size_t payloadSize = packet.size() - headerSize - 4; // Excluding CRC (4 bytes)\n\n    if (payloadSize > 0)\n    {\n        parsedFields[\"Payload Size\"] = std::to_string(payloadSize) + \" bytes\";\n    }\n    else\n    {\n        parsedFields[\"Payload Size\"] = \"No payload.\";\n    }\n\n    if (packet.size() >= headerSize + 4)\n    {\n        unsigned int crc = *reinterpret_cast<const unsigned int *>(&packet[packet.size() - 4]);\n        parsedFields[\"CRC\"] = \"0x\" + std::to_string(ntohl(crc));\n    }\n\n    return parsedFields;\n}\n```\n\nPrompt:\nThis code parses an ethernet packet to its corresponding main fields. However, I want to add functionality to validate the provided CRC in the packet whether it's correct or corrupted using `CRC32` and the polynomial \"0x04C11DB7\". Please, provide me with the full code to be executed without the `main` function, don't use placeholders, and don't change the existing functions names. Include the result in a field called `CRC Validation` while its value should be `Valid` if the CRC check is correct or `Invalid` if its corrupted."
}