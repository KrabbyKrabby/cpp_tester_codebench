{
    "time_to_develop_prompt": "30 -40",
    "programming_language": "C++",
    "task_type": "Bug Fix",
    "difficulty": "3",
    "estimated_skill_requirements": "Language-Specific Features,Data Structure and Algorithms",
    "user_prompt": "Base Code:\n```cpp\n#include <iostream>\n#include <string>\n#include <unordered_map>\n\n// Function to get the complementary base of a nucleotide\nchar complement(char nucleotide) {\n    std::unordered_map<char, char> complement_map = {\n        {'A', 'T'},\n        {'T', 'A'},\n        {'C', 'G'},\n        {'G', 'C'}\n    };\n    return complement_map[nucleotide];  \n}\n\n// Function to find the longest complementary palindromic substring\nstd::string longestPalindromeSubstring(const std::string& dna) {\n    std::string longest_palindrome_substring = \"\";\n\n    for (int i = dna.size() / 2 - 1; i >= 0; --i) {\n        if (dna[i] == complement(dna[dna.length() - i - 1])) {  \n            longest_palindrome_substring = dna.substr(i, dna.size() - i); \n        } else {\n            break;\n        }\n    }\n    return longest_palindrome_substring;\n}\n```\n\nPrompt:\nI am working on DNA sequence analysis and focusing on finding the longest palindromic substring in a DNA sequence consisting of A, T, G, and C. The substring should be a complementary palindrome, meaning its reverse is complementary to the original substring. For example, in the DNA sequence `ATCGTACGTA`, the longest complimentary palindromic substring is `CGTACG`, because its reverse `GCATGC` is complementary to it. My current implementation only works when the palindrome is located in the middle of the sequence but fails in other cases. Please correct my code to ensure it produces accurate results for all cases while maintaining a quadratic time complexity. You can use additional helper functions if required but my original function naming should not be changed."
}