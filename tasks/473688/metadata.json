{
    "time_to_develop_prompt": "30 -40",
    "programming_language": "C++",
    "task_type": "Enhancement",
    "difficulty": "3",
    "estimated_skill_requirements": "Data Structure and Algorithms,Knowledge of a Specialized Software Area",
    "user_prompt": "Base Code:\n\n```cpp\n#ifndef __CACHE_BUFFER__\n#define __CACHE_BUFFER__\n\n#include <unordered_map>\n#include <map>\n#include <list>\n#include <stdexcept>\n#include <cstddef>\n#include <queue>\n#include <algorithm> \n#include <vector>\n\ntemplate <typename Key, typename Value>\nstruct BufNode\n{\n    Key key;\n    Value value;\n    size_t frequency;\n    BufNode(const Key& k, const Value& v)\n        : key(k), value(v), frequency(1) {}\n};\n\ntemplate <typename Key, typename Value>\nclass CacheBuffer\n{\npublic:\n    explicit CacheBuffer(std::size_t capacity)\n        : m_capacity(capacity)\n    {\n        if (capacity == 0) {\n            throw std::invalid_argument(\"CacheBuffer capacity must be > 0\");\n        }\n    }\n\n    void put(const Key& key, const Value& value)\n    {\n        if (m_capacity <= 0) return;\n\n        auto it = m_map.find(key);\n        if (it != m_map.end()) {\n            it->second->value = value;\n            it->second->frequency++;\n            // Move to the front for better access locality\n            m_data.splice(m_data.begin(), m_data, it->second);\n            return;\n        }\n\n        if (size() >= m_capacity) {\n            evictNodes(1);\n        }\n\n        m_data.emplace_front(key, value);\n        m_map[key] = m_data.begin();\n    }\n\n    const Value& get(const Key& key)\n    {\n        auto it = m_map.find(key);\n        if (it == m_map.end()) {\n            throw std::runtime_error(\"Key not found in CacheBuffer\");\n        }\n        it->second->frequency++;\n        return it->second->value;\n    }\n\n    void evictNodes(int n)\n    {\n        if (n <= 0) return;\n        if (n > static_cast<int>(size())) {\n            n = size();\n        }\n\n        std::vector<typename std::list<BufNode<Key, Value>>::iterator> to_remove;\n        for (auto it = m_data.begin(); it != m_data.end(); ++it) {\n            to_remove.push_back(it);\n        }\n\n        std::sort(to_remove.begin(), to_remove.end(),\n            [](const auto& a, const auto& b) {\n                if (a->frequency == b->frequency) {\n                    return a->value > b->value;\n                }\n                return a->frequency > b->frequency;\n            });\n\n        for (int i = 0; i < n && !to_remove.empty(); ++i) {\n            auto it = to_remove[to_remove.size() - 1];\n            m_map.erase(it->key);\n            m_data.erase(it);\n            to_remove.pop_back();\n        }\n    }\n\n    std::size_t size() const\n    {\n        return m_map.size();\n    }\n\n    std::size_t capacity() const\n    {\n        return m_capacity;\n    }\n\nprivate:\n    std::size_t m_capacity;\n    std::list<BufNode<Key, Value>> m_data;\n    std::unordered_map<Key, typename std::list<BufNode<Key, Value>>::iterator> m_map;\n};\n\n#endif // __CACHE_BUFFER__\n\n```\n\nPrompt:\nEnhance the CacheBuffer class, a template class that manages elements based on their access frequencies to optimize for cache performance in scenarios where the most frequently accessed elements are prioritized. The class currently supports basic insertion and eviction based on capacity constraints. Please extend this functionality to include merging multiple cache buffers and creating snapshots of the cache's current state. \n\nList of Functions to Implement:\n1. Merge Function: `static CacheBuffer<Key, Value> mergeBuffers(const std::vector<CacheBuffer<Key, Value>>& buffers, size_t totalCapacity);`\n    a. This static method should merge multiple CacheBuffer instances into one, combining their contents while respecting a total capacity limit. \n    b. The merged buffer should retain the most frequently accessed elements if the total elements exceed the capacity.\n    c. If there are duplicate keys across buffers, their frequencies should be summed. \n    d. The method should evict the least frequently accessed elements first if the total number of elements exceeds totalCapacity.\n    e. If totalCapacity is 0 then don't use this and instead use the sum of all buffer capacity as the new value.\n\n2. Backup function: `void backup();`\n    a. This method creates a backup of the current state of the CacheBuffer internally.\n    b. Ensure that subsequent modifications to the CacheBuffer object do not affect the backup.\n\n3. Restore Function: `void restore();`\n    a. This method restores the state of the CacheBuffer from the backup. \n    b. After restoration, the current buffer should exactly mirror the state of the CacheBuffer provided as the backup, including all keys, values, and frequencies. The function must handle the transition smoothly, ensuring data consistency and integrity.\n    c. If there is an error while restoring or backing up raise a runtime_error, for example if there is no backup data.\n"
}