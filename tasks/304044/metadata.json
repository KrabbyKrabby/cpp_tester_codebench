{
    "time_to_develop_prompt": "> 40",
    "programming_language": "C++",
    "task_type": "Bug Fix",
    "difficulty": "3",
    "estimated_skill_requirements": "Language-Specific Features,Software Engineering Best Practices,Knowledge of a Specialized Software Area",
    "user_prompt": "Base Code:\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n \nusing namespace std;\n \nvector<pair<int,int>> solve(vector<int> p, vector<int> q) {\n    int n = p.size();\n \n    vector<pair<int, int>> operations;\n \n    for (int i = 0; i < n; ++i) {\n        if (p[i] != q[i]) {\n            int j = 0;\n            for (int k = 0; k < n; ++k) {\n                if (p[k] == q[i]) {\n                    j = k;\n                    break;\n                }\n            }\n            operations.push_back({i + 1, j + 1});\n            swap(p[i], p[j]);\n        }\n    }\n \n    return operations;\n}\n \nvector<vector<pair<int,int>>> solveAll(vector<vector<int>> p_s, vector<vector<int>> q_s) {\n    vector<vector<pair<int,int>>> sol;\n    for(int i = 0; i < p_s.size(); i++){\n        sol.push_back(solve(p_s[i], q_s[i]));\n    }\n    return sol;\n}\n```\nPrompt:\nYou are given two permutations, p and q, each of length n. In one operation, you can select two distinct indices i and j (where 1\u2264i, j\u2264n and \ud835\udc56 \u2260 \ud835\udc57) and swap the elements pi and pj.\nThe cost of the operation is min(|i\u2212j|, |pi\u2212pj|). The goal is to determine the minimum number of such swap operations required to transform permutation p into permutation q. \n\nThe given solution has two functions the `solveAll` takes all the cases combined in the p_s and q_s vectors relatively and it retuns the solutions combined in a vector. The other function `solve` solves each problem for one p and q. \nThe given solution also has a bug that needs to be fixed. Fix it preserving the same function prototype and don't add main. Include all needed headers and libraries.  "
}