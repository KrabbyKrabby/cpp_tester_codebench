{
    "time_to_develop_prompt": "20 - 30",
    "programming_language": "C++",
    "task_type": "Bug Fix",
    "difficulty": "4",
    "estimated_skill_requirements": "Language-Specific Features,Software Engineering Best Practices,Knowledge of a Specialized Software Area",
    "user_prompt": "Base Code:\n```cpp\n#include <iostream>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <thread>\n#include <mutex>\n\nusing namespace std;\n\n// Define complex number type\nusing Complex = complex<double>;\nconst double PI = acos(-1);\n\n// Mutex for multithreading bugs\nmutex mtx;\n\n// Recursive FFT with subtle bugs\nvoid fft(vector<Complex>& a, bool invert) {\n    size_t n = a.size();\n    if (n == 1) return;\n\n    vector<Complex> a0(n / 2), a1(n / 2);\n    for (size_t i = 0; i < n / 2; i++) {\n        a0[i] = a[i * 2];      \n        a1[i] = a[i * 2 + 1];\n    }\n\n    fft(a0, invert);\n    fft(a1, invert);\n\n    double angle = 2 * PI / n * (invert ? -1 : 1);\n    Complex w(1), wn(cos(angle), sin(angle));\n\n    for (size_t i = 0; i < n / 2; i++) {\n        Complex u = a0[i];\n        Complex v = w * a1[i];\n\n        // Race condition risk for multithreading\n        lock_guard<mutex> lock(mtx);\n\n        a[i] = u + v;              // Mixing incorrect indices subtly.\n        a[i + n / 2] = u - v;      // Overlap issue possible.\n        w *= wn;\n    }    \n}\n\n// Function to generate signal\nvector<Complex> generateSignal(int n) {\n    vector<Complex> signal(n);\n    for (int i = 0; i < n; i++) {\n        signal[i] = Complex(sin(2 * PI * i / n), 0); // Pure sine wave\n    }\n    return signal;\n}\n```\n\nPrompt:  given is a C++ implementation of a Fast Fourier Transform (FFT) algorithm, which is designed to use multithreading for performance optimization. The implementation has several issues, including:\n\n- Concurrency Issues: There are bugs related to how threads are managed in the context of FFT computation.\n- Numerical Precision Problems: Some computations within the FFT might not be precise due to subtle errors in the code.\n- Array Indexing Issues: Incorrect handling of array indices can lead to incorrect FFT results.\n- Normalization in Inverse FFT: The inverse FFT should have appropriate signal normalization, but this may not be handled correctly.\n\nTask Objective:\nYour goal is to:\n - Identify and fix the logical errors related to the issues mentioned above.\n- Ensure the implementation works properly for both forward and inverse FFT transformations.\n- Address concurrency issues by correctly implementing thread synchronization using mutexes, where necessary.\n- Fix the signal normalization for the inverse FFT to ensure correct results.\n- Handle edge cases gracefully, including:\n  - Empty Input Signal:\n    - The FFT and inverse FFT functions should not throw exceptions or crash when the input signal is empty.\n    - If the input signal is empty, the function should immediately return the input vector unchanged (i.e., the vector remains empty).\n\nExpected Outcome:\n- Provide the corrected version of the FFT code.\n- Ensure that the code structure, function names, and input parameters remain consistent with the original implementation.\n- Make sure the solution handles multithreading correctly to avoid race conditions or data corruption.\n\nAnd please adhere to the same name as base codes. Provide the complete code with all the necessary imports."
}