{
    "time_to_develop_prompt": "> 40",
    "programming_language": "C++",
    "task_type": "Refactor",
    "difficulty": "4",
    "estimated_skill_requirements": "Language-Specific Features,Knowledge of a Specialized Software Area,Software Engineering Best Practices,Library Feature",
    "user_prompt": "Base Code:\n```cpp\n#include <iostream>\n#include <cmath>\n\n// Function to apply Bilateral filter on the image\nvoid applyBilateralFilter(int** image, int width, int height, int kernelSize, float sigmaSpatial, float sigmaIntensity) {\n    int halfSize = kernelSize / 2;\n    int** result = new int*[height];\n    for (int i = 0; i < height; ++i) {\n        result[i] = new int[width];\n    }\n\n    for (int i = halfSize; i < height - halfSize; ++i) {\n        for (int j = halfSize; j < width - halfSize; ++j) {\n            float sumWeights = 0.0f;\n            float sumFiltered = 0.0f;\n\n            for (int ki = -halfSize; ki <= halfSize; ++ki) {\n                for (int kj = -halfSize; kj <= halfSize; ++kj) {\n                    int neighborX = i + ki;\n                    int neighborY = j + kj;\n\n                    // Spatial Gaussian\n                    float spatialWeight = exp(-(ki * ki + kj * kj) / (2 * sigmaSpatial * sigmaSpatial));\n\n                    // Intensity Gaussian\n                    float intensityWeight = exp(-((image[i][j] - image[neighborX][neighborY]) * (image[i][j] - image[neighborX][neighborY])) / (2 * sigmaIntensity * sigmaIntensity));\n\n                    // Combined weight\n                    float weight = spatialWeight * intensityWeight;\n\n                    sumWeights += weight;\n                    sumFiltered += weight * image[neighborX][neighborY];\n                }\n            }\n\n            result[i][j] = static_cast<int>(sumFiltered / sumWeights);\n        }\n    }\n\n    // Copy the result back into the original image\n    for (int i = 0; i < height; ++i) {\n        for (int j = 0; j < width; ++j) {\n            image[i][j] = result[i][j];\n        }\n    }\n\n    // Free the memory used for the result array\n    for (int i = 0; i < height; ++i) {\n        delete[] result[i];\n    }\n    delete[] result;\n}\n```\n\nPrompt:  \nRefactor the given `applyBilateralFilter` function while keeping the function name and input parameters unchanged. The updated implementation should include:\n\n1. Multithreading for Faster Execution:\n   - Parallelize the computation using `std::thread` to utilize multi-core processors.\n   - Ensure thread safety with `std::mutex` or other synchronization mechanisms to prevent data corruption.\n\n2. Memory Optimization and Modern C++ Best Practices:\n   - Replace raw pointers (`int**`) with `std::vector<std::vector<int>>` to manage memory safely.\n   - Avoid redundant memory allocations by modifying the image in place where possible.\n\n3. Preserve Functionality and Maintain Code Compatibility:\n   - The function must produce the same output as the original implementation but execute more efficiently.\n   - Ensure that the kernel size, spatial sigma (`sigmaSpatial`), and intensity sigma (`sigmaIntensity`) continue influencing the filter as expected.\n\n4. Handle Edge Cases Properly:\n   - Detect and handle single-pixel images (`1x1`) by ensuring the pixel remains unchanged, preventing division errors or memory issues.\n   - Handle images where the kernel size is larger than the image dimensions gracefully, avoiding out-of-bound accesses and ensuring correct pixel processing.\n\n5. Handle Images with High Intensity Variations:\n   - Ensure that the filter preserves edges effectively without introducing artifacts in images with strong contrast differences.\n   - Validate that pixels at high-intensity contrasts remain largely unchanged to preserve edge integrity.\n\n6. Maintain Consistency in Homogeneous Images:\n   - Ensure that images with uniform pixel values remain unchanged after filtering, as there are no intensity variations to smooth.\n\n7. Correct Behavior with Extremely Large and Small Sigma Values:\n   - Very Large Sigma Values (`sigmaSpatial` and `sigmaIntensity`): The filter should behave more like an averaging filter, smoothing the image uniformly.\n   - Very Small Sigma Values: The filter should preserve edges almost entirely, making minimal changes to the image.\n\nAvoid modifying the function signature. The improved function should remain compatible with existing code while enhancing speed, memory efficiency, and robustness, including proper handling of single-pixel images, high-intensity variations, homogeneous images, boundary conditions, and extreme sigma values. Provide the complete implementation along with necessary imports."
}