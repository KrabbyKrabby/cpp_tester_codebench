{
    "time_to_develop_prompt": "20 - 30",
    "programming_language": "C++",
    "task_type": "Enhancement",
    "difficulty": "3",
    "estimated_skill_requirements": "Data Structure and Algorithms,Knowledge of a Specialized Software Area,Software Engineering Best Practices",
    "user_prompt": "Base Code:\n```cpp\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n#include <stdexcept>\n\nusing namespace std;\ntypedef pair<int, int> Pair;\n\n// Function to implement Dijkstra's algorithm with negative edge weights and cycle detection\nvoid dijkstra(int start, const vector<vector<Pair>>& graph, vector<int>& distances) {\n    int n = graph.size();\n\n    // Handle empty graph scenario\n    if (n == 0) {\n        throw invalid_argument(\"Graph is empty.\");\n    }\n\n    // Check for invalid start node index\n    if (start < 0 || start >= n) {\n        throw out_of_range(\"Start node is out of range.\");\n    }\n\n    // Initialize distances with max values\n    distances.assign(n, numeric_limits<int>::max());\n    distances[start] = 0;\n\n    // Relax edges up to (n-1) times (Bellman-Ford approach)\n    for (int i = 0; i < n - 1; ++i) {\n        for (int u = 0; u < n; ++u) {\n            for (const Pair& edge : graph[u]) {\n                int v = edge.first;\n                int weight = edge.second;\n\n                // Relax the edge if a shorter path is found\n                if (distances[u] != numeric_limits<int>::max() && distances[u] + weight < distances[v]) {\n                    distances[v] = distances[u] + weight;\n                }\n            }\n        }\n    }\n\n    // Detect negative cycles and set distances to closest to 0\n    for (int u = 0; u < n; ++u) {\n        for (const Pair& edge : graph[u]) {\n            int v = edge.first;\n            int weight = edge.second;\n\n            // If further relaxation is possible, a negative cycle exists\n            if (distances[u] != numeric_limits<int>::max() && distances[u] + weight < distances[v]) {\n                distances[v] = 0; // Set distance to closest to 0\n            }\n        }\n    }\n}\n```\n\nPrompt:   Extend the provided implementation of Dijkstra's algorithm to handle graphs with negative edge weights and negative cycles. Ensure the algorithm does not enter infinite loops due to negative cycles. For nodes involved in negative cycles, return the distance closest to 0 instead of allowing infinite distance propagation. Additionally, ensure the algorithm efficiently handles large graphs and all edge cases.\nNotes:\n- Use the same function prototype\n-If the graph is empty, throw std::invalid_argument(\"Graph is empty.\").\n-If the start node is invalid (out of range), throw std::out_of_range(\"Start node is out of range.\").\n- For unreachable nodes, the distance should be std::numeric_limits<int>::max()\n- Do not implement `main()` function and don't change the function name and its parameter."
}