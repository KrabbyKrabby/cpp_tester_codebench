{
    "time_to_develop_prompt": "30 -40",
    "programming_language": "C++",
    "task_type": "Enhancement",
    "difficulty": "3",
    "estimated_skill_requirements": "Data Structure and Algorithms,Knowledge of a Specialized Software Area,Software Engineering Best Practices",
    "user_prompt": "Base Code:\n```cpp\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n\nusing namespace std;\ntypedef pair<int, int> Pair;\n\n// Function to implement Dijkstra's algorithm\nvoid dijkstra(int start, const vector<vector<Pair>> &graph) {\n    int n = graph.size();\n    vector<int> distances(n, numeric_limits<int>::max()); \n    vector<bool> visited(n, false); \n\n    priority_queue<Pair, vector<Pair>, greater<Pair>> pq;\n\n    distances[start] = 0;\n    pq.push({0, start});\n\n    while (!pq.empty()) {\n        int currentDistance = pq.top().first;\n        int currentNode = pq.top().second;\n        pq.pop();\n\n        if (visited[currentNode]) continue;\n        visited[currentNode] = true;\n\n        for (const Pair &neighbor : graph[currentNode]) {\n            int neighborNode = neighbor.first;\n            int weight = neighbor.second;\n\n            if (distances[currentNode] + weight < distances[neighborNode]) {\n                distances[neighborNode] = distances[currentNode] + weight;\n                pq.push({distances[neighborNode], neighborNode});\n            }\n        }\n    }\n\n    // Print the shortest distances from the start node\n    cout << \"Node\\tDistance from start\" << endl;\n    for (int i = 0; i < n; ++i) {\n        cout << i << \"\\t\" << distances[i] << endl;\n    }\n}\n```\n\nPrompt:\nThis is my implementation of Dijkstra's algorithm. Please help me to extend this function to support negative edges. Take care of having infinite loops, return the distance closest to 0.\n\nPlease, update the `dijkstra` function to return a vector of the shortest distances for each node from the source without changing its parameters or its name. \nPlease include any needed imports and provide the full updated version of the function without `main` function.\nNote: Don't use any other algorithm that finds the shortest path to support negative edges, stick to Dijkstra even if there will be some limitations."
}