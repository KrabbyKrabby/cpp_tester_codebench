{
    "time_to_develop_prompt": "> 40",
    "programming_language": "C++",
    "task_type": "Bug Fix",
    "difficulty": "3",
    "estimated_skill_requirements": "Language-Specific Features",
    "user_prompt": "Base Code:\n```cpp\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <thread>\n#include <mutex>\n#include <limits>\n\nusing namespace std;\n\nmutex mtx;\n\nvoid eliminateRows(vector<vector<double>>& augmentedMatrix, int startRow, int endRow, int pivotRow, int n) {\n    for (int i = startRow; i <= endRow; i++) {\n        double factor = augmentedMatrix[i][pivotRow] / augmentedMatrix[pivotRow][pivotRow];\n        for (int j = pivotRow; j <= n; j++) {\n            augmentedMatrix[i][j] -= factor * augmentedMatrix[pivotRow][j];\n        }\n    }\n}\n\nvector<double> gaussianEliminationSolver(const vector<vector<double>>& matrix, const vector<double>& constants) {\n    if (matrix.empty() || constants.size() != matrix.size() || matrix[0].size() != matrix.size()) {\n        return {};\n    }\n\n    int n = matrix.size();\n    vector<vector<double>> augmentedMatrix(n, vector<double>(n + 1));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j <= n; j++) {\n            augmentedMatrix[i][j] = (j < n) ? matrix[i][j] : constants[i];\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        int maxRow = i;\n        for (int k = i + 1; k < n; k++) {\n            if (fabs(augmentedMatrix[k][i]) > fabs(augmentedMatrix[maxRow][i])) {\n                maxRow = k;\n            }\n        }\n\n        swap(augmentedMatrix[i], augmentedMatrix[maxRow]);\n\n        vector<thread> threads;\n        int threadCount = 4;\n        int rowsPerThread = (n - i - 1) / threadCount;\n\n        for (int t = 0; t < threadCount; t++) {\n            int startRow = i + 1 + t * rowsPerThread;\n            int endRow = (t == threadCount - 1) ? n - 1 : startRow + rowsPerThread - 1;\n\n            threads.emplace_back(eliminateRows, ref(augmentedMatrix), startRow, endRow, i, n);\n        }\n\n        for (auto& t : threads) {\n            t.join();\n        }\n    }\n\n    vector<double> solution(n, 0);\n    for (int i = n - 1; i >= 0; i--) {\n        solution[i] = augmentedMatrix[i][n];\n        for (int j = i + 1; j < n; j++) {\n            solution[i] -= augmentedMatrix[i][j] * solution[j];\n        }\n        solution[i] /= augmentedMatrix[i][i];\n    }\n\n    return solution;\n}\n```\n\nPrompt: \nThe base code provided contains significant flaws and does not handle several scenarios correctly. Rewrite the `gaussianEliminationSolver` function to introduce a more robust approach utilizing recursive logic for Gaussian elimination and multithreading to parallelize calculations. The function should ensure proper validation for the input dimensions, handle pivoting for numerical stability, and appropriately return results for valid, inconsistent, or singular systems. Maintain the same input/output structure as the base code. Incorporate a secondary function to perform specific tasks and leverage multithreading to coordinate operations between the main and secondary functions, increasing computational efficiency and complexity. Only provide the corrected code, including necessary imports."
}