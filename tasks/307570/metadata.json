{
    "time_to_develop_prompt": "> 40",
    "programming_language": "C++",
    "task_type": "Completion",
    "difficulty": "3",
    "estimated_skill_requirements": "Language-Specific Features,Knowledge of a Specialized Software Area,Data Structure and Algorithms",
    "user_prompt": "\nBase Code:\n```cpp\n\n#ifndef DATA_PIPELINE_H\n#define DATA_PIPELINE_H\n\n#include <functional>\n#include <vector>\n#include <queue>\n#include <mutex>\n#include <condition_variable>\n#include <atomic>\n#include <stdexcept>\n#include <thread>\n#include <future>\n\n\ntemplate <typename T>\nclass DataPipeline {\npublic:\n    // Constructs the pipeline with given stages (function objects).\n    // Each stage is a function T -> T for simplicity. \n    explicit DataPipeline(const std::vector<std::function<T(const T&)>>& stages)\n        : stages(stages), stopFlag(false), concurrencyLevel(1)\n    {\n        if (stages.empty()) {\n            throw std::invalid_argument(\"Pipeline must have at least one stage.\");\n        }\n    }\n\n    // Adds a single item to the pipeline's input queue.\n    // In single-threaded mode, this item is processed immediately in a blocking manner.\n    // (TODO) For parallel mode, the item should be queued and processed by worker threads.\n    void push(const T& item) {\n        std::lock_guard<std::mutex> lock(mutex);\n        if (stopFlag) {\n            throw std::runtime_error(\"Cannot push to a stopped pipeline.\");\n        }\n        if (concurrencyLevel == 1) {\n            // Single-threaded immediate processing.\n            processItemInAllStages(item);\n        } else {\n            // TODO: In parallel mode, enqueue the item for worker threads to process.\n            // Possibly notify a condition variable.\n        }\n    }\n\n    // (TODO) Enables or disables concurrency with the given number of worker threads.\n    // Must be called before pushing items. \n    // If concurrencyLevel > 1, the pipeline spawns worker threads that process items in parallel.\n    // Use at least a thread-safe queue to hold incoming items, and a mechanism to \n    // distribute them across multiple threads.\n    void enableParallelism(size_t concurrencyLevel) {\n        // TODO: Implement logic to set concurrency, spawn threads, and handle safe shutdown.\n        // HINT: store concurrencyLevel in a class member, create worker threads that repeatedly \n        // grab an item from a thread-safe queue, process it, etc.\n        // Must be careful with stopFlag and draining logic.\n        if (concurrencyLevel < 1) {\n            throw std::invalid_argument(\"Concurrency level cannot be zero.\");\n        }\n    }\n\n    // (TODO) A user-defined function that is called if any stage throws an exception.\n    // The pipeline code should catch stage exceptions and invoke this callback.\n    // If no callback is set, rethrow the exception to halt processing.\n    void setErrorHandler(std::function<void(const std::exception&)> handler) {\n        // TODO: Store the handler for usage in stage execution.\n    }\n\n    // (TODO) Drains the pipeline: block until all queued items are fully processed \n    // (or until an unrecoverable error occurs).\n    // For single-thread mode, this might do nothing if each push is processed synchronously. \n    // For parallel mode, it must wait for all worker threads to complete processing of existing items.\n    void drain() {\n        // TODO: Implement logic to wait until the pipeline is empty and \n        // no in-flight items remain in parallel mode.\n    }\n\n    // Stops the pipeline and releases resources. \n    // After calling stop(), no new items can be pushed.\n    // Worker threads (if any) should finish processing current items but ignore new pushes.\n    // This function can be called multiple times safely.\n    void stop() {\n        std::lock_guard<std::mutex> lock(mutex);\n        stopFlag = true;\n        // For concurrency: notify worker threads, shut them down gracefully.\n    }\n\n    // Returns true if concurrency is enabled.\n    bool isParallel() const {\n        return concurrencyLevel > 1;\n    }\n\n    // For testing: returns the number of worker threads (0 or concurrencyLevel if in parallel mode).\n    size_t getConcurrencyLevel() const {\n        return concurrencyLevel;\n    }\n\n    // For debugging or advanced usage, allows checking the size of the item queue.\n    // For single-threaded mode, it's always 0 or 1.\n    // (TODO) Implement properly when concurrency is enabled.\n    size_t queueSize() const {\n        // TODO: Return the current number of items in the queue in parallel mode.\n        return 0; // default\n    }\n\nprivate:\n    // Helper method that processes a single item in all pipeline stages (synchronously).\n    // Catches exceptions from stages. If an exception occurs and an error handler is defined, call it.\n    // If no handler is defined, rethrow the exception.\n    void processItemInAllStages(const T& item) {\n        T current = item;\n        try {\n            for (auto& stage : stages) {\n                current = stage(current);\n            }\n        } catch (const std::exception& e) {\n            // TODO: If user errorHandler is set, call it. Otherwise rethrow.\n            // For now, just rethrow.\n            throw;\n        }\n    }\n\n    // Vector of stages, each a function T -> T.\n    std::vector<std::function<T(const T&)>> stages;\n\n    // Whether or not we've been stopped.\n    bool stopFlag;\n\n    // Current concurrency level: 1 means single-threaded immediate processing.\n    // >1 means we have concurrencyLevel-1 worker threads or concurrencyLevel threads.\n    size_t concurrencyLevel;\n\n    // Mutex for general pipeline state.\n    mutable std::mutex mutex;\n\n    // (TODO) condition_variable, or other data structures to manage concurrency in parallel mode.\n    // e.g. an std::queue<T> itemQueue, plus worker threads that pop from itemQueue.\n\n    // (TODO) user-defined error handler to handle stage exceptions.\n    // e.g. std::function<void(const std::exception&)> errorHandler;\n};\n\n#endif // DATA_PIPELINE_H\n\n```\n\nPrompt:\nEvaluate the `DataPipeline` class and implement all the methods with TODO directives. Ensure to return the entire code along with your changes. Do not implement a `main` function."
}