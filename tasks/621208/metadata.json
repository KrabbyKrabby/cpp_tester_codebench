{
    "time_to_develop_prompt": "> 40",
    "programming_language": "C++",
    "task_type": "Enhancement",
    "difficulty": "3",
    "estimated_skill_requirements": "Data Structure and Algorithms,Knowledge of a Specialized Software Area",
    "user_prompt": "Base Code:\n```cpp\n#pragma once\n\n#include <unordered_map>\n#include <list>\n#include <stdexcept>\n#include <string>\n\ntemplate<typename Key, typename Value>\nclass LRUCache {\npublic:\n    // Constructor: capacity is the maximum number of key-value pairs stored.\n    explicit LRUCache(std::size_t capacity)\n        : m_capacity(capacity)\n    {\n        if (capacity == 0) {\n            throw std::invalid_argument(\"LRUCache capacity must be > 0\");\n        }\n    }\n\n    // Return how many items are currently in the cache\n    std::size_t size() const {\n        // OPTIONAL: std::lock_guard<std::mutex> lock(m_mutex);\n        return m_list.size();\n    }\n\n    // Return the maximum capacity of the cache\n    std::size_t capacity() const {\n        return m_capacity;\n    }\n\n    // For debugging: returns a list of keys in most-recent to least-recent order\n    // (Warning: exposes internal order - for test or debugging only)\n    std::list<Key> getUsageOrder() const {\n        std::list<Key> order;\n        for (auto &pair : m_list) {\n            order.push_back(pair.first);\n        }\n        return order;\n    }\n\nprivate:\n    // capacity of the cache\n    std::size_t m_capacity;\n\n    // doubly-linked list of <key, value> pairs\n    // most recently used at front; least recently used at back\n    std::list<std::pair<Key, Value>> m_list;\n\n    // maps keys to the corresponding list iterator\n    std::unordered_map<Key, typename std::list<std::pair<Key, Value>>::iterator> m_map;\n};\n\n```\n\nPrompt:\nThe C++ code implements a basic LRUCache (Least Recently Used Cache) class. It uses a doubly linked list and an unordered_map to store key-value pairs and track usage order.\nExtend the LRUCache with the following new functionalities, and ensure it has good time and space complexity.\n1. Get function:  Value& get(const Key& key) \n    * Retrieves the value associated with 'key'. \n    * Throws a runtime error  if key not found.\n2. Put function: void put(const Key& key, const Value& value)\n    * Store a key-value pair in the cache (at the front). \n    * If the cache is full, evict the LRU entry.\n    * If key already exists, move it to the front (most recent).\n3. Time-based Expiration: void setExpirationTime(std::chrono::milliseconds ttl);\n    * Once setExpirationTime is called, every newly inserted or updated key should expire automatically ttl milliseconds after it is last updated.\n        * This (Time-based eviction) should only be enabled when the set expiration time is called, and if ttl is zero, it means it shouldn\u2019t be enabled. \n        * If a key is touched by a put or a get, reset its expiration timer.\n        * Accessing an expired key (via get or put) should throw an error (runtime_error), and remove it. \n        * The existing capacity-based eviction still applies\n4. Bulk Insertion: void putAll(const std::vector<std::pair<Key, Value>>& entries);\n    * putAll Inserts or updates a batch of key-value pairs in one shot.\n        * Must handle capacity-based eviction for each entry as needed.\n        * Must respect time-based eviction if ttl was set.\n\n"
}