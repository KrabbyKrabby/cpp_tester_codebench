{
    "time_to_develop_prompt": "> 40",
    "programming_language": "C++",
    "task_type": "Enhancement",
    "difficulty": "3",
    "estimated_skill_requirements": "Data Structure and Algorithms,Knowledge of a Specialized Software Area",
    "user_prompt": "Base Code:\n```cpp\n#ifndef __TEST_CLASS__\n#define __TEST_CLASS__\n\n#include <unordered_map>\n#include <list>\n#include <stdexcept>\n#include <cstddef>\n\ntemplate <typename Key, typename Value>\nstruct BufNode\n{\n    Key key;\n    Value value;\n    BufNode(const Key& k, const Value& v)\n        : key(k), value(v) {}\n};\n\ntemplate <typename Key, typename Value>\nclass FreqBuffer\n{\npublic:\n    explicit FreqBuffer(std::size_t capacity)\n        : m_capacity(capacity)\n    {\n        if (capacity == 0) {\n            throw std::invalid_argument(\"FreqBuffer capacity must be > 0\");\n        }\n    }\n\n    void put(const Key& key, const Value& value)\n    {\n        auto it = m_map.find(key);\n        if (it != m_map.end()) {\n            it->second->value = value;\n            return;\n        }\n\n        m_data.emplace_front(key, value);\n        // Link the key -> node in map\n        m_map[key] = m_data.begin();\n    }\n\n    const Value& get(const Key& key)\n    {\n        auto it = m_map.find(key);\n        if (it == m_map.end()) {\n            throw std::runtime_error(\"Key not found in FreqBuffer\");\n        }\n\n        return it->second->value;\n    }\n\n    std::size_t size() const\n    {\n        return m_map.size();\n    }\n\n    std::size_t capacity() const\n    {\n        return m_capacity;\n    }\n\nprivate:\n    std::size_t m_capacity;\n\n    // This list holds BufNode in no particular order (just the order inserted).\n    std::list<BufNode<Key, Value>> m_data;\n\n    // Key -> iterator in m_data\n    std::unordered_map<Key, typename std::list<BufNode<Key, Value>>::iterator> m_map;\n};\n\n\n#endif //__TEST_CLASS__\n```\n\nPrompt:\nExtend the functionality of the FreqBuffer above to include the following functionalities\n1. void resize(newCapacity) \n\nDynamically resize the cache. If shrinking, remove the least frequently used item until size() <= newCapacity.\nIf newCapacity is less than zero raise an error, if it is zero then reduce the buffer capacity to zero\n\n2. std::vector<std::pair<Key, Value>> getTopKFrequent(k)\n\nReturn the k key-value pair with the highest frequency in descending frequency order. Ties should be in ascending Value order.\n\n3.  void pop_least_used(n) \n\nRemoves the n number of least frequently used elements in the cache. \n\nNote:\nEnsure all functions are public and the solution provides all the necessary includes and defines needed to make the program work. \n\n"
}